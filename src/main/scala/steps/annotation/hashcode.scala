package steps.annotation

import scala.annotation.{experimental, MacroAnnotation}
import scala.quoted.*

/**
 * A macro annotation that generates a custom `hashCode` method for a class, based on its fields.
 * 
 * The `@hashCode` annotation automatically generates a `hashCode` method that takes into account all the fields 
 * of the class that are marked as parameter accessors (i.e., fields passed through the class constructor). 
 * This hash code implementation follows Java's `hashCode` contract, using the standard hashing algorithm.
 * 
 * Example usage:
 * {{{
 * @hashCode
 * class Person(name: String, age: Int)
 *
 * val person1 = Person("Alice", 25)
 * val person2 = Person("Bob", 30)
 * 
 * val hash1 = person1.hashCode() // Automatically generated hash code based on name and age fields.
 * val hash2 = person2.hashCode() // Different hash code as the fields differ.
 * }}}
 * 
 * The generated `hashCode` method uses `scala.runtime.Statics` methods for efficient hashing of primitive types and 
 * other objects.
 * 
 * @note The annotation is only allowed in classes. It cannot be applied to traits or objects, and attempting to do so will 
 *       result in a compilation error. Furthermore, if the class already defines a `hashCode` method, a warning will be issued, 
 *       indicating that the `@hashCode` annotation is unnecessary.
 * 
 * @note This annotation requires Scala's `experimental` flag to be enabled, or it can be used within an experimental scope 
 *       (i.e., `import scala.annotation.experimental`), as it utilizes experimental macro annotation features.
 */
@experimental
final class hashCode extends MacroAnnotation:

  /**
   * Transforms the annotated class by adding a `hashCode` method based on its fields.
   * 
   * If the class already defines a `hashCode` method, a warning is issued, and the existing class definition is returned unchanged.
   * If the class is a trait or object, an error is raised, as `@hashCode` is only supported in classes.
   * 
   * The `hashCode` method is generated by combining the hash codes of all fields using a standard hashing algorithm.
   * 
   * @param tree The abstract syntax tree (AST) of the annotated class.
   * @return The transformed class definition with the generated `hashCode` method.
   */
  override def transform(using Quotes)(tree: quotes.reflect.Definition): List[quotes.reflect.Definition] = 
    import quotes.reflect.*
    val hashCodeSym = Symbol.requiredMethod("java.lang.Object.hashCode")
    tree match
      case _: ClassDef if hashCodeSym.overridingSymbol(tree.symbol).exists => 
        report.warning(s"@hashCode is not necessary since hashCode is defined in ${tree.symbol}")
        List(tree)
      case cls: ClassDef if cls.symbol.flags.is(Flags.Trait) =>
        report.error(s"@hashCode is not supported in traits")
        List(tree)
      case cls: ClassDef if cls.symbol.flags.is(Flags.Module) =>
        report.error(s"@hashCode is not supported in object")
        List(tree)
      case ClassDef(className, ctr, parents, self, body) =>
        val cls = tree.symbol

        val fields = body.collect:
          case vdef: ValDef if vdef.symbol.flags.is(Flags.ParamAccessor) =>
            Select(This(cls), vdef.symbol).asExpr
        end fields

        val hashCodeOverrideSym = Symbol.newMethod(cls, hashCodeSym.name, hashCodeSym.info, Flags.Override | Flags.Final, Symbol.noSymbol)
        val hashCodeOverrideDef = DefDef(hashCodeOverrideSym, _ =>
          given Quotes = hashCodeOverrideSym.asQuotes
          Some(hashCodeExpr(className, fields).asTerm)
        )

        List(ClassDef.copy(tree)(className, ctr, parents, self, hashCodeOverrideDef  :: body))
      case _ => 
        report.errorAndAbort("@hashCode is only supported in class")
    
  end transform

  /**
   * Generates the body of the `hashCode` method.
   *
   * The method computes the hash code by combining the hash codes of all the class fields using a standard hashing algorithm.
   * Primitive types are hashed using `scala.runtime.Statics` for efficient handling.
   * 
   * @param className The name of the class being annotated.
   * @param thisFields The list of fields to include in the hash code computation.
   * @return An expression representing the generated `hashCode` method body.
   */
  private def hashCodeExpr(className: String, thisFields: List[Expr[Any]])(using Quotes): Expr[Int] =
  '{
    var acc: Int = ${ Expr(scala.runtime.Statics.mix(-889275714, className.hashCode)) }
    ${
      Expr.block(
        thisFields.map {
          case '{ $field: Boolean } => '{ if $field then 1231 else 1237 }
          case '{ $field: Byte } => '{ $field.toInt }
          case '{ $field: Char } => '{ $field.toInt }
          case '{ $field: Short } => '{ $field.toInt }
          case '{ $field: Int } => field
          case '{ $field: Long } => '{ scala.runtime.Statics.longHash($field) }
          case '{ $field: Double } => '{ scala.runtime.Statics.doubleHash($field) }
          case '{ $field: Float } => '{ scala.runtime.Statics.floatHash($field) }
          case '{ $field: Null } => '{ 0 }
          case '{ $field: Unit } => '{ 0 }
          case field => '{ scala.runtime.Statics.anyHash($field) }
        }.map(hash => '{ acc = scala.runtime.Statics.mix(acc, $hash) }),
        '{ scala.runtime.Statics.finalizeHash(acc, ${Expr(thisFields.size)}) }
      )
    }
  }
  end hashCodeExpr


end hashCode