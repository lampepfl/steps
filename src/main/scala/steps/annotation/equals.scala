package steps.annotation

import scala.annotation.{experimental, MacroAnnotation}
import scala.quoted.*

/**
 * A macro annotation that automatically generates an `equals` method for a class, based on its fields.
 *
 * The `@equals` annotation defines an `equals` method for a class by comparing all fields marked as parameter accessors 
 * (i.e., fields passed through the class constructor). This generated method follows the contract of the `equals` method 
 * defined in `java.lang.Object`, ensuring that equality is based on field-by-field comparison.
 *
 * Example usage:
 * {{{
 * @equals
 * class Person(name: String, age: Int)
 *
 * val person1 = Person("Alice", 25)
 * val person2 = Person("Alice", 25)
 * val person3 = Person("Bob", 30)
 *
 * person1 == person2 // true, as the fields are identical.
 * person1 == person3 // false, as the fields differ.
 * }}}
 *
 * The `equals` method compares instances of the class and determines whether their fields are equal.
 * The comparison is performed in a type-safe manner, ensuring that fields of the correct type are compared.
 *
 * @note The annotation is only allowed on classes. It cannot be applied to traits or objects, and attempting to do so 
 *       will result in a compilation error. Additionally, if the class already defines an `equals` method, a warning 
 *       will be issued, indicating that the `@equals` annotation is unnecessary.
 *
 * @note This annotation requires Scala's `experimental` flag to be enabled, or it can be used within an experimental scope 
 *       (i.e., `import scala.annotation.experimental`), as it utilizes experimental macro annotation features.
 */
@experimental
final class equals extends MacroAnnotation:

  /**
   * Transforms the annotated class by adding an `equals` method based on its fields.
   *
   * If the class already defines an `equals` method, a warning is issued, and the existing class definition is returned unchanged.
   * If the class is a trait or object, an error is raised, as `@equals` is only supported in regular classes.
   *
   * The `equals` method is generated by comparing each field of the class with the corresponding field of the other object.
   * 
   * @param tree The abstract syntax tree (AST) of the annotated class.
   * @return The transformed class definition with the generated `equals` method.
   */
  override def transform(using Quotes)(tree: quotes.reflect.Definition): List[quotes.reflect.Definition] =
    import quotes.reflect.*
    val equalsSym = Symbol.requiredMethod("java.lang.Object.equals")
    tree match
      case _: ClassDef if equalsSym.overridingSymbol(tree.symbol).exists =>
        report.warning(s"@equals is not necessary since equals is defined in ${tree.symbol}")
        List(tree)
      case cls: ClassDef if cls.symbol.flags.is(Flags.Trait) =>
        report.error(s"@equals is not supported in traits")
        List(tree)
      case cls: ClassDef if cls.symbol.flags.is(Flags.Module) =>
        report.error(s"@equals is not supported in object")
        List(tree)
      case ClassDef(className, ctr, parents, self, body) =>
        val cls = tree.symbol
        val equalsOverrideSym = Symbol.newMethod(cls, equalsSym.name, equalsSym.info, Flags.Override, Symbol.noSymbol)

        val fields = body.collect {
          case vdef: ValDef if vdef.symbol.flags.is(Flags.ParamAccessor) =>
            Select(This(cls), vdef.symbol).asExpr
        }

        def equalsOverrideDefBody(argss: List[List[Tree]]): Option[Term] =
          import quotes.reflect.*
          given Quotes = equalsOverrideSym.asQuotes
          cls.typeRef.asType match
            case '[c] =>
              Some(equalsExpr[c](argss.head.head.asExpr, fields).asTerm)
        end equalsOverrideDefBody

        val equalsDefDef = DefDef(equalsOverrideSym, equalsOverrideDefBody)
        List(ClassDef.copy(tree)(className, ctr, parents, self, equalsDefDef :: body))
      case _ =>
        report.errorAndAbort("@equals is only supported in class")
  end transform

  /**
   * Generates the body of the `equals` method.
   *
   * The method compares the fields of the class to those of another object to determine equality.
   * If the other object is of the same type, the comparison is done field-by-field; otherwise, the method returns `false`.
   *
   * @param thatExpr The object being compared against (`that` in the `equals` method).
   * @param thisFields The list of fields to compare.
   * @return An expression representing the body of the `equals` method.
   */
  private def equalsExpr[T: Type](that: Expr[Any], thisFields: List[Expr[Any]])(using Quotes): Expr[Boolean] =
    '{
      $that match
        case that: T @unchecked =>
          ${
            val thatFields: List[Expr[Any]] =
              import quotes.reflect.*
              thisFields.map(field => Select('{that}.asTerm, field.asTerm.symbol).asExpr)
            thisFields.zip(thatFields)
              .map { case (thisField, thatField) => '{ $thisField == $thatField } }
              .reduce { case (pred1, pred2) => '{ $pred1 && $pred2 } }
          }
        case _ => false
    }
  end equalsExpr

end equals